
# 拔河比赛

前置准备：

* 前人工作：无
* 技术栈：react + ws
* 平台选择：
  * MemFire 数据库 免费一个实例 国内 基于supabase 支持基于ws的realtime
  * Cloudflare 页面托管 后面可上 cdn 全球业务拓展预备
  * github 代码仓库

## 逻辑

1. 玩家首先输入用户名
   1. 不存在则创建
2. 然后选择进行游戏/查看历史/旁观战局（需要房间id，未来功能）
3. 选择游戏后：
   1. 选择是开房还是加入
      1. 开房需要写人数（可选，默认两个）
   2. 选择左右
   3. 等待玩家加入
   4. 人齐后开赛
      1. 全局ws重连
      2. 假设多点击一边比另一边多点击10下获胜
   5. 比赛结果展示
   6. 回到 2


关于比赛时对数据库的更新：

* 如果每次点击都更新数据库，则会导致数据库压力过大。那么需要一种方法来对数据进行周期性的更新。
  * 由谁进行更新？何时进行更新？
  * 由谁：可以投票或基于某个规则选出其中一个玩家进行更新。
    * 如果投票：需要知道每个用户的id，那么这就需要在游戏开始的时候同步一次所有玩家信息。每次需要更新时，随机选择一个玩家，由票数最多的玩家进行更新操作。那么会存在一个新的问题：每个人都有掉线的风险，那么怎么规避选出来的人不在线而导致没更新？
    * 如果基于规则：例如可以每个人来个随机数，由数字最大/最小的那个进行更新。那么做的好处在于只要产生了随机数就能代表用户在线。
    * 所以最重要的问题是怎么确保更新者是在线的？或者说，怎么辨别人掉线了？
    * ~~那么可以周期性的进行广播，说我在线。~~ 好的，supabase有个Presence可以办到这个。
    * 那么现在问题解决了，无论是投票还是基于某种规则，都可以有一个确定的主体可以发送更新操作。
  * 何时：可以选择一个期望时长，例如每秒更新一次。新的问题：
    * 网络延迟：如果是固定更新周期，例如游戏开始每秒更新一次，则可以以游戏开始时间戳确定准确的更新时间点。
      * 想到个极端例外：玩家可能在第1s更新了，可是由于网络延迟，导致服务器在第3s才收到更新操作，此时就不能将旧的数据写入进去。所以应该在数据库中记录最后更新时间戳，以免旧数据覆盖新数据。
    * 设备性能：如果用户设备性能足够差，会导致操作不能及时处理和发出。所以在这点上，会存在每个人的时间尺度可能是不一样的情况。这个暂时不考虑。

玩家掉线/刷新后如何恢复？

## 数据库

### user 表

* 存放用户信息
* `id` 主键 `int8`
* `username` `text` 唯一的（按目前需求来说这样做可以使用户可以用相同的用户名重新登录，反正不需要密码，正常的项目中应该使用auth功能而非数据库中建立user表）
* `created_at` 创建时间 `timestamptz`

```sql
create table
  public.user (
    id bigint generated by default as identity,
    username text not null,
    created_at timestamp with time zone not null default now(),
    constraint user_pkey primary key (id),
    constraint user_id_key unique (id),
    constraint user_username_key unique (username)
  ) tablespace pg_default;
```

### hist 表

* 存放用户的历史比赛数据
* `id` 主键 `int8`
* `uid` 外键（`user.id`）
* `is_winner` bool
* `click_count` 点击次数 int4
* `created_at` 创建时间 `timestamptz`

```sql
create table
  public.hist (
    id bigint generated by default as identity,
    uid bigint not null,
    is_winner boolean not null,
    click_count integer not null,
    created_at timestamp with time zone not null default now(),
    constraint hist_pkey primary key (id),
    constraint hist_id_key unique (id),
    constraint hist_uid_fkey foreign key (uid) references "user" (id) on delete cascade
  ) tablespace pg_default;
```

### room 表

* 房间信息，只有房间在比赛时存在，比赛后将删除（其实这里应该做一个房间池的概念，限制房间总数）
* `id` 主键 `int8`
* `room_size` 拔河总人数 `int2`
* `win_threshold` 赢的数量（一边比一边多这么多就算赢，一般是人数*10） `int4`
* `left_count` 左边的人点击总数 `int4` max(2^31 - 1)
* `right_count` 右边的人点击总数 `int4` max(2^31 - 1)
* `updated_at` 更新发出时的毫秒时间戳 `int8`
* `created_at` 创建时间 `timestamptz`

```sql
create table
  public.room (
    id bigint generated by default as identity,
    room_size smallint not null,
    win_threshold integer not null,
    left_count integer not null,
    right_count integer not null,
    updated_at bigint not null default '0'::bigint,
    created_at timestamp with time zone not null default now(),
    constraint room_pkey primary key (id),
    constraint room_id_key unique (id),
    constraint room_left_count_check check ((left_count < 1073741823)),
    constraint room_right_count_check check ((right_count < 1073741823))
  ) tablespace pg_default;

create or replace function check_and_update_room()
returns trigger as $$
begin
  if new.updated_at <= old.updated_at then
    return null;
  end if;
  return new;
end;
$$ language plpgsql;

create trigger
  before_update_room before update
on public.room
for each row
  execute function check_and_update_room();
```

### user_room 表

* 存放房间内用户信息，例如是否是观战还是正在游玩、玩家当前的点击数，用户/房间删除后自动删除
* `uid` 主键 外键（`user.id`） delete cascade
* `rid` 外键（`room.id`） delete cascade
* `click_count` 点击次数 `int4`
* `is_left` 是左边队伍 `bool`
* `is_player` 是参赛选手 `bool`

```sql
create table
  public.user_room (
    `uid` bigint not null,
    rid bigint not null,
    click_count integer not null default 0,
    is_left boolean not null,
    is_player boolean not null default false,
    constraint user_room_pkey primary key (id),
    constraint user_room_id_key unique (id),
    constraint user_room_id_fkey foreign key (id) references "user" (id) on delete cascade,
    constraint user_room_rid_fkey foreign key (rid) references room (id) on delete cascade
  ) tablespace pg_default;
```
